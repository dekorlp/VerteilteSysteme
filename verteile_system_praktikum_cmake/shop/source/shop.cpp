/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/* 
 * File:   main.cpp
 * Author: michael
 *
 * Created on 25. Mai 2017, 13:58
 */

// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "../gen-cpp/ShopRequest.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <iostream>
#include <thread>
#include "Mqtt.h"
#include "MqttHandler.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

Mqtt *mqtt;
std::string id = "Rewe";
extern bool isConnected;
extern bool isDisconnected;

int mengeMilch = 100; // Sensor0
int mengeKaese = 100;
int mengeCola = 100;
int mengeFleisch = 100;

int sensorPrice1 = 2;
int sensorPrice2 = 5;
int sensorPrice3 = 3;
int sensorPrice4 = 4;

Bill bill;

class ShopRequestHandler : virtual public ShopRequestIf {
public:

    ShopRequestHandler() {
        // Your initialization goes here
    }
    
    int32_t requestProduct(const int32_t sendorId, const int32_t bestellMenge) {
        // Your implementation goes here
        int price;
        
        switch (sendorId) {
            case(0):
                        price = sensorPrice1;
                        
                break;
            case(1):
                        price = sensorPrice2;
                        
                break;
            case(2):
                        price = sensorPrice3;
                        
                break;
            case(3):
                        price = sensorPrice4;
                       
        }
        
        printf("requestProduct\n");
        return price;
    }

    void buyProducts(ProductAnswer& _return, const int32_t sendorId, const int32_t bestellMenge) {
        // Your implementation goes here

        ProductAnswer pA;
     

        pA.sensorId = sendorId;
        pA.menge = bestellMenge;
        switch (sendorId) {
            case(0):
                    pA.preis = sensorPrice1;
                    mengeMilch = mengeMilch - bestellMenge;
                    if(mengeMilch <= 20) mqtt->publish(std::string("Nachfrage/Shop/"+id+ "/Milch").c_str(),"Nachfrage/Produzent/Milch", 1, onPublishSucceded);
                break;
            case(1):
                    pA.preis = sensorPrice2;
                    mengeKaese = mengeKaese - bestellMenge;
                    if(mengeKaese <= 20) mqtt->publish(std::string("Nachfrage/Shop/"+id+ "/Käse").c_str(),"Nachfrage/Produzent/Käse", 1, onPublishSucceded);
                break;
            case(2):
                    pA.preis = sensorPrice3;
                    mengeCola = mengeCola - bestellMenge;
                    if(mengeCola <= 20) mqtt->publish(std::string("Nachfrage/Shop/"+id+ "/Cola").c_str(),"Nachfrage/Produzent/Cola", 1, onPublishSucceded);
                break;
            case(3):
                    pA.preis = sensorPrice4;
                    mengeFleisch = mengeFleisch - bestellMenge;
                    if(mengeFleisch <= 20) mqtt->publish(std::string("Nachfrage/Shop/"+id+ "/Fleisch").c_str(),"Nachfrage/Produzent/Fleisch", 1, onPublishSucceded);
        }

       
        bill.produkte.push_back(pA);
        _return = pA;
        
        printf("buyProducts\n");
    }

    void getBill(Bill& _return) {
        // Your implementation goes here
        _return = bill;
        printf("getBill\n");
    }

    void ping() {
        // Your implementation goes here
        printf("ping\n");
    }

};

int msgarrvd(void *context, char *topicName, int topicLen, MQTTAsync_message *message)
{
    char* cMessage;
    cMessage = (char*)calloc( message->payloadlen+1, sizeof(char));
    strcpy( cMessage, (char*)message->payload);
    cMessage[message->payloadlen] = '\0';
    std::string sMessage = std::string(cMessage);
    //free(cMessage);
    
    if(topicName == std::string("Nachfrage/Shop/"+id+ "/Milch"))
    {
        int positionHash = sMessage.find(';');
        std::string preise = sMessage.substr(0, positionHash);
        std::string bestellungTopic = sMessage.substr(positionHash+1, sMessage.length());
        
        std::cout << "Nachfrage/Produzent/Milch" << std::endl;
        mqtt->publish(std::string("Bestellung/Shop/"+id+ "/Milch").c_str(), bestellungTopic.c_str(), 1, onPublishSucceded);
        
    }
    else if(topicName == std::string("Nachfrage/Shop/"+id+ "/Käse"))
    {
        int positionHash = sMessage.find(';');
        std::string preise = sMessage.substr(0, positionHash);
        std::string bestellungTopic = sMessage.substr(positionHash+1, sMessage.length());
        
        std::cout << "Nachfrage/Produzent/Käse" << std::endl;
        mqtt->publish(std::string("Bestellung/Shop/"+id+ "/Käse").c_str(), bestellungTopic.c_str(), 1, onPublishSucceded);
    }
    else if(topicName == std::string("Nachfrage/Shop/"+id+ "/Cola"))
    {
        int positionHash = sMessage.find(';');
        std::string preise = sMessage.substr(0, positionHash);
        std::string bestellungTopic = sMessage.substr(positionHash+1, sMessage.length());
        
        std::cout << "Nachfrage/Produzent/Cola" << std::endl;
        mqtt->publish(std::string("Bestellung/Shop/"+id+ "/Cola").c_str(), bestellungTopic.c_str(), 1, onPublishSucceded);
    }
    else if(topicName == std::string("Nachfrage/Shop/"+id+ "/Fleisch"))
    {
        int positionHash = sMessage.find(';');
        std::string preise = sMessage.substr(0, positionHash);
        std::string bestellungTopic = sMessage.substr(positionHash+1, sMessage.length());
        
        std::cout << "Nachfrage/Produzent/Fleisch" << std::endl;
        mqtt->publish(std::string("Bestellung/Shop/"+id+ "/Fleisch").c_str(), bestellungTopic.c_str(), 1, onPublishSucceded);
    }
    else if(topicName == std::string("Bestellung/Shop/"+id+ "/Milch"))
    {
        int positionHash = sMessage.find(';');
        std::string menge = sMessage.substr(0, positionHash);
        std::string preis = sMessage.substr(positionHash+1, sMessage.length());
        mengeMilch +=   std::stoi (menge);
        
        std::cout << std::endl << "Milch: " << menge << " für "<< preis << std::endl;
        std::cout << "Bestand - Milch: " << mengeMilch << std::endl << std::endl;
    }
    else if(topicName == std::string("Bestellung/Shop/"+id+ "/Käse"))
    {
        int positionHash = sMessage.find(';');
        std::string menge = sMessage.substr(0, positionHash);
        std::string preis = sMessage.substr(positionHash+1, sMessage.length());
        mengeKaese += std::stoi (menge);
        
        std::cout << std::endl << "Käse: " << menge << " für "<< preis << std::endl;
        std::cout << "Bestand - Käse: " << mengeKaese << std::endl << std::endl;
    }
    else if(topicName == std::string("Bestellung/Shop/"+id+ "/Cola"))
    {
        int positionHash = sMessage.find(';');
        std::string menge = sMessage.substr(0, positionHash);
        std::string preis = sMessage.substr(positionHash+1, sMessage.length());
        mengeCola += std::stoi (menge);
        
        std::cout << std::endl << "Cola: " << menge << " für "<< preis << std::endl;
        std::cout << "Bestand - Cola: " << mengeMilch << std::endl << std::endl;
    }
    else if(topicName == std::string("Bestellung/Shop/"+id+ "/Fleisch"))
    {
        int positionHash = sMessage.find(';');
        std::string menge = sMessage.substr(0, positionHash);
        std::string preis = sMessage.substr(positionHash+1, sMessage.length());
        mengeFleisch += std::stoi (menge);
        
        std::cout << std::endl << "Fleisch: " << menge << " für "<< preis << std::endl;
        std::cout << "Bestand - Fleisch: " << mengeFleisch << std::endl << std::endl;
    }
    //std::cout << std::endl << std::endl;
    //std::cout << "Message arrived" << std::endl << "topic: " << topicName << std::endl;
    //std::cout << "message: ";
    //std::cout << (char*)message->payload<<std::endl;
    
    free(cMessage);
    MQTTAsync_freeMessage(&message);
    MQTTAsync_free(topicName);
    return 1;
}

void subscribeThread()
{
    std::string ipAdresse = "tcp://192.168.56.3:1883";
    
    
    mqtt = new Mqtt(ipAdresse.c_str(), id.c_str(), connlost, msgarrvd, onConnect, onConnectFailure);    
    while(!isConnected); // warte bis Verbindung aufgebaut ist
    
    
    mqtt->subscribe(std::string("Nachfrage/Shop/"+id+ "/Milch").c_str(), 1, onSubscribeFailure, onSubscribe);
    mqtt->subscribe(std::string("Nachfrage/Shop/"+id+ "/Käse").c_str(), 1, onSubscribeFailure, onSubscribe);
    mqtt->subscribe(std::string("Nachfrage/Shop/"+id+ "/Cola").c_str(), 1, onSubscribeFailure, onSubscribe);
    mqtt->subscribe(std::string("Nachfrage/Shop/"+id+ "/Fleisch").c_str(), 1, onSubscribeFailure, onSubscribe);
    mqtt->subscribe(std::string("Bestellung/Shop/"+id+ "/Milch").c_str(), 1, onSubscribeFailure, onSubscribe);
    mqtt->subscribe(std::string("Bestellung/Shop/"+id+ "/Käse").c_str(), 1, onSubscribeFailure, onSubscribe);
    mqtt->subscribe(std::string("Bestellung/Shop/"+id+ "/Cola").c_str(), 1, onSubscribeFailure, onSubscribe);
    mqtt->subscribe(std::string("Bestellung/Shop/"+id+ "/Fleisch").c_str(), 1, onSubscribeFailure, onSubscribe);
    
    
    int ch;
    do 
    {
        //if(ch == 's' || ch == 's')
        //{
        //    mqtt->subscribe("hda/test", 1, onSubscribeFailure, onSubscribe);
        //}
        
        if(ch == 'p' || ch == 'P')
        {
            int publishInput;
            while(publishInput !='B' && publishInput != 'b')
            {
                
                std::cout << "Bestellen: Milch: m"<<std::endl;
                std::cout << "Bestellen: Käse: k"<<std::endl;
                std::cout << "Bestellen: Cola: c"<<std::endl;
                std::cout << "Bestellen: Fleisch: f"<<std::endl;
                std::cout << "Zurueck: b"<<std::endl;
                std::cout << "Eingabe: ";
                
                
                if(publishInput == 'm' || publishInput == 'M')
                {
                    mqtt->publish(std::string("Nachfrage/Shop/"+id+ "/Milch").c_str(),"Nachfrage/Produzent/Milch", 1, onPublishSucceded);
                }
                else if(publishInput == 'k' || publishInput == 'K')
                {
                    mqtt->publish(std::string("Nachfrage/Shop/"+id+ "/Käse").c_str(),"Nachfrage/Produzent/Käse", 1, onPublishSucceded);
                }
                else if(publishInput == 'c' || publishInput == 'C')
                {
                    mqtt->publish(std::string("Nachfrage/Shop/"+id+ "/Cola").c_str(),"Nachfrage/Produzent/Cola", 1, onPublishSucceded);
                }
                else if(publishInput == 'f' || publishInput == 'F')
                {
                    mqtt->publish(std::string("Nachfrage/Shop/"+id+ "/Fleisch").c_str(),"Nachfrage/Produzent/Fleisch", 1, onPublishSucceded);
                }
                publishInput = getchar();
                publishInput = getchar();
            }
        }
       
        //if(ch == 'u' || ch == 'U')
        //{
        //    mqtt->unsubscribe("hda/test", onUnSubscribe);
        //}
        
        ch = getchar();
    } while (ch!='Q' && ch != 'q');
    
    mqtt->disconnect(onDisconnect);
    
    while(!isDisconnected); // // warte bis Verbindung abgebaut wurde
    
}


void thriftThread()
{
    int port = 9090;
    shared_ptr<ShopRequestHandler> handler(new ShopRequestHandler());
    shared_ptr<TProcessor> processor(new ShopRequestProcessor(handler));
    shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
    shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
    server.serve();
}

int main(int argc, char **argv) {
    
    std::cout << "Preis für Sensor 1: ";
    std::cin >> sensorPrice1;
    std::cout << std::endl;
    
    std::cout << "Preis für Sensor 2: ";
    std::cin >> sensorPrice2;
    std::cout << std::endl;
    
    std::cout << "Preis für Sensor 3: ";
    std::cin >> sensorPrice3;
    std::cout << std::endl;
    
    std::cout << "Preis für Sensor 4: ";
    std::cin >> sensorPrice4;
    std::cout << std::endl;
    
    std::thread t1;
    std::thread t2;
    
    t2 = std::thread(thriftThread);
    t1 = std::thread(subscribeThread);
    
    t1.join();
    t2.join();
    
    
    
    return 0;
}
